// below is a minimal definition of something we can work with - Nat and summation on it!
// let's implement it all the way!!! following the MVP principle - do not build wheels for a car,
// build a scooter first!

/*
function f(x,y,z, h) = {
  { n, Z, Cons (a1, Cell (b1, b2) ), Succ(Succ(Z)) } -> g (n,a1,b1,b2)
};
*/

/*
type Bool = { True, False };

function id (x:a):a = x;

function not (b:Bool) : Bool = {
    {True}  -> False,
    {False} -> True
};


function eq(x:Nat,y:Nat):Bool = {
  {Z,Z} -> True,
  {Z,n} -> False,
  {Succ(m),Succ(n)} -> eq(m,n)
};
*/

type Nat = {
  Z,
  Succ (n:Nat)
};

function plus (x:Nat,y:Nat):Nat = {
  {Z, n} -> n, // case x of Z -> case y of x -> x
  {Succ(n,n1), m} -> Succ (plus(n,n1, m)) // case x of Succ(n) -> case y of x -> Succ(plus(n,x))
};

/*
function plus2 (x:Nat):Nat = plus(x, Succ(Succ(Z)) );

action main = {
  one = Succ(Z),
  three = Succ(Succ(one)),
  res = plus(three,one),
  print# (res)
};
*/
