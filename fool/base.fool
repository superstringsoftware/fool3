// below is a minimal definition of something we can work with - Nat and summation on it!
// let's implement it all the way!!! following the MVP principle - do not build wheels for a car,
// build a scooter first!

type Bool = { True, False }

function not (b:Bool) : Bool = {
    True -> False,
    False -> True
}

type Nat = {
  Z,
  Succ (:Nat)
}

function plus (x:Nat,y:Nat):Nat = {
  (Z, x) -> x,
  (Succ(n), x) -> Succ (plus(n,x))  
}

