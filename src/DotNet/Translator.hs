{-# LANGUAGE OverloadedStrings, NamedFieldPuns, FlexibleInstances #-}

module DotNet.Translator where

import Control.Monad.IO.Class
import DependentTypes.Core

{-
data Expr
    = Lit Literal
    | VarId Name -- for bound variables and functions???
    | Lam   Name [Var] Expr -- named function. To be non-partially applied, needs all arguments (size of Var list)
    | Tuple Name [Expr] -- polymorphic tuple: main thing for values generated by ADTs
    | App Expr Expr -- e1 can only be Lam or VarId, e2 can only be Tuple - so there should be a better way to handle this
    | If  Expr Expr Expr -- will get rid of this once case patterns are in, since we can model it with a function
    | Let Name Expr Expr -- ok, need to figure out how GHC does it - here we are binding first Expr to symbol Name in 2nd Expr
    -- Case, for instance: case x of Nothing -> Nothing; (Just x) -> Just x*2 translates to something like:
    -- Case "x" [ (Nothing, Nothing), (cons x == Just, Just (x*2)) ]
    | Case [(Expr, Expr)]
    -- whatever goes below is for interpreter / initial parsing
    | Index !Integer -- used for Tuple element access and maybe some other stuff?
    | RecAccess Expr Expr -- first try, first expr is either VarId or Index - named field - second expr is to what we apply
    -- so, f.a would be RecAccess (VarId "a") (VarId "f")
    -- f.a.b: RecAccess (varId "b") (RecAccess (VarId "a") (VarId "f"))
    | BinaryOp Name Expr Expr
    | UnaryOp  Name Expr
    | FAIL String -- some invalid expression
    deriving (Eq, Ord, Show)
  
  mkTuple x = Tuple "" [x]
  mk2Tuple x y = Tuple "" [x, y]
  
  data Literal = LInt !Int | LFloat !Double | LChar !Char |
                 LString !String | LBool !Bool | LList [Expr] | LVec [Expr]
                 deriving (Eq, Ord, Show)
  
  data Var = Id Name Type | TyVar Name Kind
    deriving (Show, Eq, Ord)
-}