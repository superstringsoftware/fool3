{-# LANGUAGE OverloadedStrings, NamedFieldPuns, FlexibleInstances #-}

module DotNet.Syntax where

-- import TermColors
import Data.Char (isUpper)

import Data.Functor.Identity
import Control.Monad.IO.Class

type Name = String

-- anything that can be on the right side of ':' in expressions - so a type or a kind or type function that may depend on values etc
data Type
    = TVar Name -- TVar -- a:* - careful, we CANNOT use 'Id' constructor from Var here
    | TCon Name -- TyCon -- Maybe, String, Int etc - just a name of the constructor
    | TApp Type Type -- Constructor application - Maybe Int, List a etc
    | TArr Type Type -- Function sig - Maybe a -> String etc
    | TForall [Pred] [TVar] Type
    | ToDerive -- added it to handle initial parsing
    | InsType Expr -- this is probably a workaround - when we are beta-reducing Type lambdas for variables like \a. x:a
    -- "a" needs to be able to become any kind of expression (since we are applying lambdas to expressions).
    -- Type checking etc will fix this.
    deriving (Show, Eq, Ord)

-- Since we are doing dependent types, we need to be able to do both the standard:
-- Maybe :: * -> * as well as something for Vector a:* n:Int which would look like:
-- Vector :: * -> Int -> *
-- We are using KTerm constructor to describe it - just need to be careful, since valid value there is only
-- *Concrete* type!
data Kind
    = KStar
    | KArr Kind Kind
    | KPrim
    | KVar Name
    | KTerm Type
    deriving (Show, Eq, Ord)
  
data TyCon
    = AlgTyCon { tyId :: Name }
    | PrimTyCon { tyId :: Name }
    deriving (Show, Eq, Ord)

data Pred
    = IsIn Name Type
    deriving (Show, Eq, Ord)

data Var = Id Name Type | TyVar Name Kind
    deriving (Show, Eq, Ord)
  
type TVar = Var -- type synonim to handle Forall predicates


data Literal = LInt !Int | LFloat !Double | LChar !Char |
               LString !String | LBool !Bool | LList [Expr] | LVec [Expr]
               deriving (Eq, Ord, Show)

-- we need to handle dependent types, this is first attempt by storing specific value var
{-
data TupleField 
    = TypedField Type -- regular field with a type
    | ConstField 
-}
-- product type constructor
data Cons = Anon Name [Type] | Record Name [(Name, Type)] deriving (Eq, Ord, Show)

-- Surfance language AST type to handle both lazy and strict hopefully a bit more efficiently
-- So, no currying
data Expr 
    = Lit Literal
    | VarId Name
    | Type Name [Var] [Cons] -- sum type built from product constructors cons
    | BinaryOp Name Expr Expr
    | UnaryOp  Name Expr
    | Tuple Name [Expr] -- polymorphic tuple
    | App Expr Expr
    deriving (Eq, Ord, Show)

{-
Examples for Type:
type Maybe a:* = Nothing + Just :a -->
Type "Maybe" [TyVar "a" KStar] [
    Tuple "Nothing" [],
    Tuple "Just" [TVar "a"]
]
type Tagged a:* tag:String = Tagged :a tag -->
Type "Tagged" [TyVar "a" KStar, Id "tag" (TCon "String")] [
    Tuple "Tagged" [TVar "a", TVar "tag"] -- this is somewhat misleading, no?
]    
type Vector a:* n:Int = Vector (primvector a n) -->
-}

{-
data Expr
  = Lit Literal
  | VarId Name -- for bound variables and functions???
  | Lam   Name [Var] Expr -- named function. To be non-partially applied, needs all arguments (size of Var list)
  | Tuple Name [Expr] -- polymorphic tuple: main thing for values generated by ADTs
  | App Expr Expr -- e1 can only be Lam or VarId, e2 can only be Tuple - so there should be a better way to handle this
  | If  Expr Expr Expr -- will get rid of this once case patterns are in, since we can model it with a function
  | Let Name Expr Expr -- ok, need to figure out how GHC does it - here we are binding first Expr to symbol Name in 2nd Expr
  -- Case, for instance: case x of Nothing -> Nothing; (Just x) -> Just x*2 translates to something like:
  -- Case "x" [ (Nothing, Nothing), (cons x == Just, Just (x*2)) ]
  | Case [(Expr, Expr)]
  -- whatever goes below is for interpreter / initial parsing
  | Index !Integer -- used for Tuple element access and maybe some other stuff?
  | RecAccess Expr Expr -- first try, first expr is either VarId or Index - named field - second expr is to what we apply
  -- so, f.a would be RecAccess (VarId "a") (VarId "f")
  -- f.a.b: RecAccess (varId "b") (RecAccess (VarId "a") (VarId "f"))
  | BinaryOp Name Expr Expr
  | UnaryOp  Name Expr
  | FAIL String -- some invalid expression
  deriving (Eq, Ord, Show)
-}

-- mkTuple x = Tuple "" [x]
-- mk2Tuple x y = Tuple "" [x, y]




varName (Id n _) = n
varName (TyVar n _) = n
varType (Id _ t) = t



