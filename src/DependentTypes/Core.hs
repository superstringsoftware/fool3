{-# LANGUAGE OverloadedStrings, NamedFieldPuns, FlexibleInstances #-}

module DependentTypes.Core where

import TermColors
import Data.Char (isUpper)

import Data.Functor.Identity
import Control.Monad.IO.Class

type Name = String

{-
Moving to new approach: everything is a tuple
-}

-- Core AST type to handle both lazy and strict hopefully a bit more efficiently
-- So, no currying
data Expr
  = Lit Literal
  | VarId Name -- for bound variables and functions???
  | Lam   Name [Var] Expr -- named function. To be non-partially applied, needs all arguments (size of Var list)
  | Tuple Name [Expr] -- polymorphic tuple: main thing for values generated by ADTs
  | App Expr Expr -- e1 can only be Lam or VarId, e2 can only be Tuple - so there should be a better way to handle this
  | If  Expr Expr Expr -- will get rid of this once case patterns are in, since we can model it with a function
  | Let Name Expr Expr -- ok, need to figure out how GHC does it - here we are binding first Expr to symbol Name in 2nd Expr
  -- Case, for instance: case x of Nothing -> Nothing; (Just x) -> Just x*2 translates to something like:
  -- Case "x" [ (Nothing, Nothing), (cons x == Just, Just (x*2)) ]
  | Case [(Expr, Expr)]
  -- whatever goes below is for interpreter / initial parsing
  | BinaryOp Name Expr Expr
  | UnaryOp  Name Expr
  | FAIL String -- some invalid expression
  deriving (Eq, Ord, Show)

mkTuple x = Tuple "" [x]
mk2Tuple x y = Tuple "" [x, y]

data Literal = LInt !Int | LFloat !Double | LChar !Char |
               LString !String | LBool !Bool | LList [Expr] | LVec [Expr]
               deriving (Eq, Ord, Show)

data Var = Id Name Type | TyVar Name Kind
  deriving (Show, Eq, Ord)

type TVar = Var -- type synonim to handle Forall predicates

varName (Id n _) = n
varName (TyVar n _) = n
varType (Id _ t) = t


-- anything that can be on the right side of ':' in expressions - so a type or a kind or type function that may depend on values etc
data Type
  = TVar Name -- TVar -- a:* - careful, we CANNOT use 'Id' constructor from Var here
  | TCon Name -- TyCon -- Maybe, String, Int etc - just a name of the constructor
  | TApp Type Type -- Constructor application - Maybe Int, List a etc
  | TArr Type Type -- Function sig - Maybe a -> String etc
  | TForall [Pred] [TVar] Type
  | ToDerive -- added it to handle initial parsing
  | InsType Expr -- this is probably a workaround - when we are beta-reducing Type lambdas for variables like \a. x:a
  -- "a" needs to be able to become any kind of expression (since we are applying lambdas to expressions).
  -- Type checking etc will fix this.
  deriving (Show, Eq, Ord)

-- Since we are doing dependent types, we need to be able to do both the standard:
-- Maybe :: * -> * as well as something for Vector a:* n:Int which would look like:
-- Vector :: * -> Int -> *
-- We are using KTerm constructor to describe it - just need to be careful, since valid value there is only
-- *Concrete* type!
data Kind
  = KStar
  | KArr Kind Kind
  | KPrim
  | KVar Name
  | KTerm Type
  deriving (Show, Eq, Ord)

data TyCon
  = AlgTyCon { tyId :: Name }
  | PrimTyCon { tyId :: Name }
  deriving (Show, Eq, Ord)

data Pred
  = IsIn Name Type
  deriving (Show, Eq, Ord)

{-
-- GHC Core:
type CoreExpr = Expr Var

data Expr b	-- "b" for the type of binders,
  = Var	  Id
  | Lit   Literal
  | App   (Expr b) (Arg b)
  | Lam   b (Expr b)
  | Let   (Bind b) (Expr b)
  | Case  (Expr b) b Type [Alt b]
  | Cast  (Expr b) Coercion
  | Tick  (Tickish Id) (Expr b)
  | Type  Type

type Arg b = Expr b
type Alt b = (AltCon, [b], Expr b)

data AltCon = DataAlt DataCon | LitAlt  Literal | DEFAULT

data Bind b = NonRec b (Expr b) | Rec [(b, (Expr b))]
-}

-------------------------------------------------------------------------------
-- AST manipulation stuff
-------------------------------------------------------------------------------
-- calculate arity of an expression: trivial in our language approach
arity :: Expr -> Int
arity (Lam _ v _) = length v

-- Expr traversals with modifying function f::Expr->Expr
traverseExpr :: (Expr -> Expr) -> Expr -> Expr
traverseExpr f (Lam nm v e) = Lam nm v (f e)
traverseExpr f (Tuple nm ex) = Tuple nm (map f ex)
traverseExpr f (App e1 e2) = App (f e1) (f e2)
traverseExpr f (If e1 e2 e3) = If (f e1) (f e2) (f e3)
traverseExpr f (Let nm e1 e2) = Let nm (f e1) (f e2)
traverseExpr f (BinaryOp nm e1 e2) = BinaryOp nm (f e1) (f e2)
traverseExpr f (UnaryOp nm e) = UnaryOp nm (f e)
traverseExpr f e = f e

{-
= Lit Literal
| Tuple Name [Expr] -- polymorphic tuple: main thing for values generated by ADTs
-}

descendM :: (Monad m, Applicative m) => (Expr -> m Expr) -> Expr -> m Expr
descendM f e = case e of
    App  a b        -> App <$> descendM f a <*> descendM f b
    VarId  a        -> VarId <$> pure a
    Lam nm v e      -> Lam <$> pure nm <*> pure v <*> descendM f e
    Lit  n          -> Lit <$> pure n
    Let  n a b      -> Let <$> pure n <*> descendM f a <*> descendM f b
    If a b c        -> If <$> descendM f a <*> descendM f b <*> descendM f c
    BinaryOp n a b  -> BinaryOp <$> pure n <*> descendM f a <*> descendM f b
    UnaryOp n a     -> UnaryOp <$> pure n <*> descendM f a
    Tuple nm ex     -> Tuple <$> pure nm <*> mapM (descendM f) ex
    Case exs        -> Case <$> mapM (fn f) exs
                                  where fn f1 (e1, e2) = do
                                                            e1' <- descendM f1 e1
                                                            e2' <- descendM f1 e2
                                                            return (e1', e2')
    >>= f -- to apply actual change function on the way out of the traversal

-- pure traversal in the identity monad
descend :: (Expr -> Expr) -> Expr -> Expr
descend f ex = runIdentity (descendM (return . f) ex)

-- for now, this simply kills all Binary / Unary op calls and changes them to function applications
desugar :: Expr -> Expr
desugar = descend f
 where
   f (UnaryOp nm e) = App (VarId $ "("++nm++")") (mkTuple e)
   f (BinaryOp nm e1 e2) = App (VarId $ "("++nm++")") (mk2Tuple e1 e2)
   f (Lam nm [] expr) = expr -- flattening lambda applications with zero arguments - they should return only expression.
   -- need this since our parser returns Lam nm [] ex for bindings like v = square x etc
   f x = x

betaReduce :: Name -> Expr -> Expr -> Expr
betaReduce name value = descend (f name value)
  where
    f nm val e@(VarId vname) = if nm == vname then val else e
    f nm val x = x


-------------------------------------------------------------------------------
-- Pretty Print typeclass
-------------------------------------------------------------------------------
class PrettyPrint a where
  prettyPrint :: a -> String

instance PrettyPrint Expr where
  prettyPrint (VarId n) = n
  -- prettyPrint (Lam nm [] (Tuple tnm [])) = clrLam nm
  prettyPrint (Lam nm vars e) = foldr fn "" vars ++ prettyPrint e -- clrLam nm ++ " = " ++
      where fn el acc = as [bold, dgray] "Î»" ++ prettyPrint el ++ ". " ++ acc
  prettyPrint (Tuple nm tpl) = clrLam nm ++ showBracketedList " {" "}" tpl -- clrLam nm ++
  prettyPrint (Lit l) = prettyPrint l
  prettyPrint (App e1 e2) = prettyPrint e1 ++ " " ++ prettyPrint e2
  prettyPrint (If e1 e2 e3) = as [bold, green] "if " ++ prettyPrint e1 ++
                              as [bold, green] " then " ++ prettyPrint e2 ++
                              as [bold, green] " else " ++ prettyPrint e3
  prettyPrint (Let nm e1 e2) = as [bold, green] "let " ++ nm ++ " = " ++ prettyPrint e1 ++
                            as [bold, green] " in " ++ prettyPrint e2

  prettyPrint (BinaryOp n e1 e2) = "("++n++") " ++ prettyPrint e1 ++ " " ++ prettyPrint e2
  prettyPrint (Case exs) = foldr fn "" exs
      where fn (e1,e2) acc = "\n\t| " ++ prettyPrint e1 ++ " -> " ++ prettyPrint e2 ++ acc
  prettyPrint e = show e

clrLam "" = ""
clrLam s = if isUpper (head s) then as [bold, red] s else as [bold, green] s


embrace s = as [bold, blue] "(" ++ s ++ as [bold, blue] ")"
-- additional nicer formatting for output for top level expressions
prettyPrintTopLevel (App e1 e2) = embrace (prettyPrint e1) ++ embrace (prettyPrint e2)
prettyPrintTopLevel e = prettyPrint e


showBracketedList l r [] = ""
showBracketedList l r [x]    = l ++ prettyPrint x ++ r
showBracketedList l r (x:xs) = l ++ prettyPrint x ++ foldr fn "" xs ++ r
    where fn el acc = ", " ++ prettyPrint el ++ acc


instance PrettyPrint Literal where
  prettyPrint (LInt x) = as [magenta] $ show x
  prettyPrint (LFloat x) = as [magenta] $ show x
  prettyPrint (LBool x) = as [magenta] $ show x
  prettyPrint (LString s) = as [green] $ show s
  prettyPrint (LList tuple) = showBracketedList "[" "]" tuple
  prettyPrint (LVec  tuple)  = showBracketedList "<" ">" tuple
  prettyPrint e = show e

instance PrettyPrint Type where
  prettyPrint (TVar nm) = nm
  prettyPrint (TCon nm) = as [yellow, bold] nm
  prettyPrint ToDerive  = as [dgray, bold] "?"
  prettyPrint (TApp t1 t2) = "(" ++ prettyPrint t1 ++ " " ++ prettyPrint t2 ++")"
  prettyPrint (InsType ex) = prettyPrint ex
  prettyPrint e = show e

{-
  | TArr Type Type
  | TForall [Pred] [TVar] Type
-}

instance PrettyPrint Var where
  prettyPrint (Id nm tp)   = nm ++ ":" ++ prettyPrint tp
  prettyPrint (TyVar nm k) = nm ++ ":" ++ prettyPrint k

instance PrettyPrint Kind where
  prettyPrint KStar = "*"
  prettyPrint k = show k
